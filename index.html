<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Neon Survivor - Blade Update</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        canvas {
            background-color: #111;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.1);
            border: 1px solid #333;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-left: 4px solid #00aaff;
            border-radius: 0 4px 4px 0;
            backdrop-filter: blur(4px);
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            transition: border-color 0.3s;
        }

        .stat-box.boss-mode {
            border-left-color: #ff0000 !important;
            background: rgba(50, 0, 0, 0.7);
        }

        .stat-label {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
        }

        .hp-bar-bg,
        .exp-bar-bg {
            width: 180px;
            background: #333;
            margin-top: 5px;
            overflow: hidden;
        }

        .hp-bar-bg {
            height: 8px;
            border-radius: 4px;
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff0000);
            transition: width 0.2s;
        }

        .exp-bar-bg {
            height: 5px;
            border-radius: 3px;
        }

        .exp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #adff2f);
            transition: width 0.2s;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(10px);
        }

        .title {
            font-size: 60px;
            font-weight: 900;
            color: #00aaff;
            text-shadow: 0 0 20px #00aaff;
            letter-spacing: 5px;
            margin-bottom: 20px;
            text-align: center;
        }

        .subtitle {
            font-size: 20px;
            color: #fff;
            margin-bottom: 50px;
            opacity: 0.8;
            letter-spacing: 2px;
        }

        .btn {
            padding: 15px 50px;
            font-size: 24px;
            background: transparent;
            color: #00aaff;
            border: 2px solid #00aaff;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .btn:hover {
            background: #00aaff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.8);
            transform: scale(1.05);
        }

        .mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }

        .audio-controls {
            position: absolute;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 12px;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            z-index: 100;
            pointer-events: auto;
            width: 180px;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
        }

        .audio-controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            color: #aaa;
            letter-spacing: 1px;
        }

        .audio-controls input[type="range"] {
            width: 100%;
            accent-color: #00aaff;
        }

        #bossWarning {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 50px;
            font-weight: bold;
            text-shadow: 0 0 20px red;
            display: none;
            z-index: 15;
            pointer-events: none;
            letter-spacing: 10px;
            animation: blink 0.5s infinite;
        }

        #systemError {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px red;
            display: none;
            z-index: 15;
            pointer-events: none;
            letter-spacing: 3px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 15px;
            border: 1px solid red;
            animation: blink 0.2s infinite;
        }

        #systemError.steady {
            animation: none;
            opacity: 1;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="ui" style="display:none;">
        <div class="stat-box" id="scoreBox">
            <div class="stat-label">Score</div>
            <div class="stat-value" id="scoreDisplay">0</div>
        </div>
        <div class="stat-box" id="waveBox" style="border-left-color: #ffaa00;">
            <div class="stat-label">Wave <span id="waveNum">1</span></div>
            <div class="stat-value" id="timeDisplay">00:00</div>
        </div>
        <div class="stat-box" id="hpBox" style="border-left-color: #ff4444;">
            <div class="stat-label">HP <span id="hpText">100/100</span></div>
            <div class="hp-bar-bg">
                <div class="hp-bar-fill" id="hpBar"></div>
            </div>
        </div>
        <div class="stat-box" id="lvlBox" style="border-left-color: #00ff00;">
            <div class="stat-label">Level <span id="levelText">1</span></div>
            <div class="exp-bar-bg">
                <div class="exp-bar-fill" id="expBar"></div>
            </div>
        </div>
        <div class="stat-box" id="wepBox" style="border-left-color: #ffffff;">
            <div class="stat-label">Weapons (Max 3)</div>
            <div class="stat-value" id="weaponDisplay" style="font-size: 12px;"></div>
        </div>
    </div>

    <div id="bossWarning">WARNING: BOSS DETECTED</div>
    <div id="systemError">WEAPON SYSTEM ERROR</div>

    <div id="overlay">
        <div class="title">NEON SURVIVOR</div>
        <div class="subtitle">WASD to Move | Boss Every 5 Waves</div>
        <button class="btn" id="startBtn">SYSTEM START</button>
    </div>

    <div class="audio-controls" id="audioControls" style="display:none;">
        <label for="volumeSlider">VOLUME <span id="volumeValue">30%</span></label>
        <input type="range" id="volumeSlider" min="0" max="100" value="30" step="1">
    </div>

    <button class="mute-btn" id="muteBtn" style="display:none;">ðŸ”Š MUTE</button>
    <canvas id="gameCanvas"></canvas>

    <!-- Merged Scripts -->
    <script>
        // --- Data.js ---
        const enemyTypes = {
            normal: { hpMul: 1.0, spdMul: 1.0, color: '#ff4444', shape: 'square' },
            tank: { hpMul: 3.0, spdMul: 0.6, color: '#ff8844', shape: 'hexagon' },
            runner: { hpMul: 0.5, spdMul: 1.5, color: '#ff44aa', shape: 'triangle' }
        };

        const weaponsInitial = {
            gun: { name: 'Plasma Gun', color: '#ffff00', description: 'Auto-fires at nearest enemy.', attackPower: 12, range: 320, cooldown: 28 },
            scatter: { name: 'Scatter Shot', color: '#ffaa00', description: 'Close-range spread fire.', attackPower: 9, range: 180, cooldown: 55, count: 5, spread: 0.6 },
            whip: { name: 'Nano Whip', color: '#ff00ff', description: 'Slashes BOTH sides.', attackPower: 45, range: 180, cooldown: 65 },
            blade: { name: 'Photon Blade', color: '#00ffaa', description: 'Orbiting plasma blade.', attackPower: 25, range: 100, cooldown: 0, count: 1, rotSpeed: 0.08 },
            sanctuary: { name: 'Void Field', color: '#00ffff', description: 'Damages enemies in aura.', attackPower: 1.5, range: 110, cooldown: 10 },
            laser: { name: 'Railgun', color: '#ff0000', description: 'Pierces all enemies in line.', attackPower: 20, range: 480, cooldown: 60 },
            bomb: { name: 'Plasma Grenade', color: '#ff8800', description: 'Throws an explosive bomb.', attackPower: 40, range: 250, cooldown: 110, explosionRadius: 100 },
            thunder: { name: 'Tesla Coil', color: '#ffff88', description: 'Chains lightning to enemies.', attackPower: 22, range: 360, cooldown: 80, chainCount: 4 },
            mine: { name: 'Spider Mine', color: '#ffff00', description: 'Drops mines that seek enemies.', attackPower: 35, range: 80, cooldown: 120, duration: 400, blastRadius: 95 }
        };

        // Deep clone for actual use
        let weapons = JSON.parse(JSON.stringify(weaponsInitial));

        const upgrades = [
            { id: 'atk', name: 'Power Up', description: 'DMG +20%', apply: () => player.weapons.forEach(k => weapons[k].attackPower *= 1.2) },
            { id: 'spd', name: 'Agility', description: 'Speed +10%', apply: () => player.speed *= 1.1 },
            { id: 'hp', name: 'Vitality', description: 'HP +20 & Heal', apply: () => { player.maxHp += 20; player.hp = player.maxHp; } },
            {
                id: 'cdr',
                name: 'Overclock',
                description: 'Cooldown -10%',
                apply: () => player.weapons.forEach(k => {
                    const w = weapons[k];
                    w.cooldown *= 0.9;
                    if (w.rotSpeed) w.rotSpeed /= 0.9; // tie blade speed to cooldown buffs
                })
            },
            {
                id: 'rng',
                name: 'Scope',
                description: 'Range +20%, Area +10%',
                apply: () => {
                    player.weapons.forEach(k => {
                        weapons[k].range *= 1.20;
                        if (weapons[k].explosionRadius) weapons[k].explosionRadius *= 1.10;
                        if (weapons[k].blastRadius) weapons[k].blastRadius *= 1.10;
                    });
                    addFloatingText(player.x, player.y, 'SCOPE UP!', '#00ffff');
                }
            },
            { id: 'mag', name: 'Magnet', description: 'Pickup +30%', apply: () => player.magnetRadius *= 1.3 },
            { id: 'exp', name: 'Learning', description: 'EXP +6%', apply: () => player.expMult += 0.06 },
            {
                id: 'curse',
                name: 'Cursed Sigil',
                description: 'Enemy HP +30%, EXP +50%',
                apply: () => {
                    enemyGlobalHpMul *= 1.3;
                    player.expMult += 0.5;
                    addFloatingText(player.x, player.y, "CURSED!", "#8800ff");
                }
            },
            {
                id: 'adrenaline',
                name: 'Adrenaline',
                description: 'Low HP = Faster Cooldown',
                apply: () => {
                    player.adrenaline++;
                    addFloatingText(player.x, player.y, "RUSH!", "#ff0055");
                }
            },
            {
                id: 'vital_strike',
                name: 'Vital Strike',
                description: 'Full HP = High DMG',
                apply: () => {
                    player.vitalStrike++;
                    addFloatingText(player.x, player.y, "VITAL!", "#00ff88");
                }
            },
            {
                id: 'fortress',
                name: 'Fortress',
                description: 'Armor UP, Speed DOWN',
                apply: () => {
                    player.damageReduction += 0.15; // 15% reduction
                    player.speed *= 0.9; // 10% slow
                    addFloatingText(player.x, player.y, "ARMOR UP!", "#888888");
                }
            }
        ];

        const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

        // --- Audio.js ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.masterVolume = 0.3;
                this.isMuted = false;
                this.isPlayingBGM = false;
                this.nextNoteTime = 0;
                this.tempo = 110;
                this.current16thNote = 0;
                this.timerID = null;
                this.isBossMode = false;
                this.currentWave = 1;

                // Music Pattern
                this.normalBass = [36, 0, 36, 0, 36, 36, 38, 0, 33, 0, 33, 0, 33, 33, 35, 0];
                this.normalArp = [60, 63, 67, 63, 60, 63, 67, 63, 57, 60, 64, 60, 57, 60, 64, 60];

                // Boss Pattern (Faster, more aggressive)
                this.bossBass = [36, 36, 36, 36, 39, 39, 38, 38, 36, 36, 36, 36, 33, 33, 35, 35];
                this.bossArp = [60, 60, 72, 72, 63, 63, 75, 75, 57, 57, 69, 69, 62, 62, 74, 74];

                this.isSystemError = false;
                this.isOverheating = false;
                this.overheatTimerID = null;
            }

            init() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.masterVolume;
                this.masterGain.connect(this.ctx.destination);
            }

            soundTime(allowSystemError = false) {
                if (!this.ctx || this.isMuted || (!allowSystemError && this.isSystemError)) return null;
                return this.ctx.currentTime;
            }

            createNoiseBuffer(duration) {
                const bufferSize = Math.floor(this.ctx.sampleRate * duration);
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.setValueAtTime(this.isMuted ? 0 : this.masterVolume, this.ctx.currentTime);
                }
                return this.isMuted;
            }

            setVolume(value) {
                this.masterVolume = clamp(value, 0, 1);
                if (this.masterGain && !this.isMuted) {
                    this.masterGain.gain.setValueAtTime(this.masterVolume, this.ctx.currentTime);
                }
            }

            setBossMode(enabled) {
                this.isBossMode = enabled;
                this.updateTempo();
            }

            setSystemError(enabled) {
                this.isSystemError = enabled;
                if (!enabled) {
                    this.isOverheating = false;
                    if (this.overheatTimerID) {
                        clearTimeout(this.overheatTimerID);
                        this.overheatTimerID = null;
                    }
                }
            }

            triggerOverheatSequence() {
                if (this.isOverheating || this.isSystemError) return;
                this.isOverheating = true;

                this.overheatTimerID = setTimeout(() => {
                    if (this.isOverheating) {
                        this.setSystemError(true);
                        this.playErrorBeep();
                        const errorElement = document.getElementById('systemError');
                        errorElement.style.display = 'block';

                        setTimeout(() => {
                            errorElement.classList.add('steady');
                        }, 3000);
                    }
                }, 2000);
            }

            playErrorBeep() {
                if (!this.ctx || this.isMuted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, t);
                osc.frequency.setValueAtTime(440, t + 0.2);
                osc.frequency.setValueAtTime(880, t + 0.4);
                osc.frequency.setValueAtTime(440, t + 0.6);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.8);

                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.8);
            }

            setWave(wave) {
                this.currentWave = clamp(wave, 1, 50);
                this.updateTempo();
            }

            updateTempo() {
                const effectiveWave = Math.min(this.currentWave || 1, 30);
                const waveProgress = effectiveWave / 30;
                const baseTempo = 110 + (waveProgress * 40);
                this.tempo = this.isBossMode ? baseTempo + 20 : baseTempo;
            }

            playShoot() {
                const t = this.soundTime();
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(this.isBossMode ? 900 : 800, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.1);
            }

            playShotgun() {
                const t = this.soundTime();
                if (t == null) return;
                // Burst noise/sawtooth for impact
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.2);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.2);
            }

            playBlade() {
                const t = this.soundTime();
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.1);

                gain.gain.setValueAtTime(0.05, t); // Low volume (constant loop-like)
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.15);
            }

            playRailgun() {
                const t = this.soundTime();
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.exponentialRampToValueAtTime(150, t + 0.2);
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.2);
            }

            playWhip() {
                const t = this.soundTime();
                if (t == null) return;
                const buffer = this.createNoiseBuffer(0.1);

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(2000, t);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                noise.start();
            }

            playThunder() {
                const t = this.soundTime();
                if (t == null) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.3);

                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.3);

                const noise = this.ctx.createBufferSource();
                noise.buffer = this.createNoiseBuffer(0.3);

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 500;
                noiseFilter.Q.value = 1;

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.1, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start();
            }

            playExplosion() {
                const t = this.soundTime();
                if (t == null) return;
                const noise = this.ctx.createBufferSource();
                noise.buffer = this.createNoiseBuffer(0.4);
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, t);
                filter.frequency.linearRampToValueAtTime(10, t + 0.3);
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                noise.start();
            }

            playBossSpawn() {
                const t = this.soundTime(true);
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 1.0);
                gain.gain.setValueAtTime(0.64, t);
                gain.gain.linearRampToValueAtTime(0.01, t + 1.0);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 1.0);
            }

            playLevelUp() {
                const t = this.soundTime(true);
                if (t == null) return;
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, t + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.08 + 0.2);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(t + i * 0.08); osc.stop(t + i * 0.08 + 0.2);
                });
            }

            playGem() {
                const t = this.soundTime(true);
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1500, t);
                osc.frequency.linearRampToValueAtTime(2000, t + 0.05);
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.05);
            }

            playGlitch() {
                const t = this.soundTime(true);
                if (t == null) return;
                const osc = this.ctx.createOscillator();
                osc.type = Math.random() > 0.5 ? 'sawtooth' : 'square';
                osc.frequency.value = Math.random() * 500 + 50;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.05;
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(t); osc.stop(t + Math.random() * 0.1);
            }

            playGameOver() {
                const t = this.soundTime(true);
                if (t == null) return;

                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 1.5);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.linearRampToValueAtTime(0, t + 1.5);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.linearRampToValueAtTime(100, t + 1.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t); osc.stop(t + 1.5);
            }

            midiToFreq(note) { return 440 * Math.pow(2, (note - 69) / 12); }
            scheduleNote(beat, time) {
                if (beat % 4 === 0) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                    gain.gain.setValueAtTime(this.isBossMode ? 0.7 : 0.6, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(time); osc.stop(time + 0.5);
                }
                if (this.isBossMode) {
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = this.createNoiseBuffer(0.05);

                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass'; filter.frequency.value = 8000;

                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.03, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

                    noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                    noise.start(time);
                }

                const bassLine = this.isBossMode ? this.bossBass : this.normalBass;
                const arpLine = this.isBossMode ? this.bossArp : this.normalArp;

                const bassNote = bassLine[beat % 16];
                if (bassNote) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    osc.type = 'sawtooth'; osc.frequency.value = this.midiToFreq(bassNote);
                    filter.type = 'lowpass'; filter.frequency.setValueAtTime(this.isBossMode ? 500 : 300, time);
                    filter.frequency.linearRampToValueAtTime(100, time + 0.2);
                    gain.gain.setValueAtTime(0.2, time);
                    gain.gain.linearRampToValueAtTime(0.01, time + 0.2);
                    osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                    osc.start(time); osc.stop(time + 0.25);
                }
                const arpNote = arpLine[beat % 16];
                if (arpNote) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = this.midiToFreq(arpNote + 12);
                    gain.gain.setValueAtTime(0.05, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(time); osc.stop(time + 0.3);
                }
            }
            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.scheduleNote(this.current16thNote, this.nextNoteTime);
                    this.nextNoteTime += 0.25 * (60.0 / this.tempo);
                    this.current16thNote = (this.current16thNote + 1) % 16;
                }
                this.timerID = window.setTimeout(() => this.scheduler(), 25);
            }
            startBGM() {
                if (!this.ctx || this.isPlayingBGM) return;
                this.isPlayingBGM = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.scheduler();
            }
        }

        // --- Entities.js ---
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x + (Math.random() - 0.5) * 20; this.y = y;
                this.text = text; this.color = color;
                this.life = 40; this.vy = -1.5;
            }
            update() { this.y += this.vy; this.life--; }
            draw() {
                if (this.life <= 0) return;
                const sx = this.x - camera.x, sy = this.y - camera.y;
                ctx.globalAlpha = this.life / 40; ctx.fillStyle = this.color;
                ctx.font = "bold 20px Arial"; ctx.fillText(this.text, sx, sy);
                ctx.globalAlpha = 1.0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const a = Math.random() * 6.28; const s = Math.random() * 3 + 1;
                this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
                this.life = 30; this.size = Math.random() * 3 + 1;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; this.vx *= 0.9; this.vy *= 0.9; }
            draw() {
                ctx.globalAlpha = this.life / 30; ctx.fillStyle = this.color;
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.size, this.size); ctx.globalAlpha = 1;
            }
        }

        class Bullet {
            constructor(x, y, tx, ty, isEnemy = false, maxDist = 9999) {
                this.x = x; this.y = y; this.size = isEnemy ? 6 : 5;
                this.isEnemy = isEnemy;
                this.startPos = { x, y };
                this.maxDist = maxDist;
                const a = Math.atan2(ty - y, tx - x);
                this.speed = (isEnemy ? 6 : 10);
                this.vx = Math.cos(a) * this.speed;
                this.vy = Math.sin(a) * this.speed;
                // Life determines range if maxDist provided
                this.life = isEnemy ? 120 : (maxDist / this.speed);
                this.marked = false;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life--;

                // For scatter shot: fade out near end
                this.alpha = 1;
                if (!this.isEnemy && this.life < 10) {
                    this.alpha = this.life / 10;
                }

                if (this.life <= 0) {
                    this.marked = true;
                    // Visual effect for disappearing bullet (range limit)
                    if (!this.isEnemy) {
                        particles.push(new Particle(this.x, this.y, '#ffaa00'));
                    }
                }
            }
            draw() {
                ctx.fillStyle = this.isEnemy ? '#ff0000' : '#ffff00';
                if (!this.isEnemy && weapons.scatter && this.maxDist < 2000) ctx.fillStyle = weapons.scatter.color; // Scatter color

                ctx.globalAlpha = this.alpha || 1;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath(); ctx.arc(this.x - camera.x, this.y - camera.y, this.size, 0, 6.28); ctx.fill(); ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        class BombProjectile {
            constructor(x, y, tx, ty) {
                this.x = x; this.y = y; this.tx = tx; this.ty = ty;
                this.height = 0; this.progress = 0;
                this.marked = false;
                const dist = Math.hypot(tx - x, ty - y);
                this.duration = dist / 8; // Speed
                this.vx = (tx - x) / this.duration;
                this.vy = (ty - y) / this.duration;
            }
            update() {
                this.progress++;
                this.x += this.vx;
                this.y += this.vy;
                const p = this.progress / this.duration;
                this.height = Math.sin(p * Math.PI) * 50;

                if (this.progress >= this.duration) {
                    this.marked = true;
                    this.explode();
                }
            }
            explode() {
                createParticles(this.x, this.y, '#ff8800', 30);
                soundManager.playExplosion();
                const r = weapons.bomb.explosionRadius;
                const dmg = weapons.bomb.attackPower * getDamageMultiplier();

                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < r + e.size) {
                        const damageMult = 1 - (dist / r) * 0.5;
                        e.takeDamage(dmg * damageMult);
                    }
                });
                bombs.push({ x: this.x, y: this.y, r: 0, maxR: r, alpha: 1 });
            }
            draw() {
                const sx = this.x - camera.x;
                const sy = this.y - camera.y - this.height;
                ctx.fillStyle = '#ff8800';
                ctx.beginPath(); ctx.arc(sx, sy, 6, 0, 6.28); ctx.fill();
            }
        }

        class RotatingBlade {
            constructor(angleOffset) {
                this.angle = angleOffset;
            }
            update(weaponData, speedBoost = 1) {
                this.angle += weaponData.rotSpeed * speedBoost;
                const range = weaponData.range;

                // Blade Geometry (Sweeping Beam)
                const startDist = 10;
                const tipX = player.x + Math.cos(this.angle) * range;
                const tipY = player.y + Math.sin(this.angle) * range;
                const startX = player.x + Math.cos(this.angle) * startDist;
                const startY = player.y + Math.sin(this.angle) * startDist;

                const thickness = 25 * (range / 100);

                if (frameCount % 10 === 0) { // Hit tick
                    enemies.forEach(e => {
                        // Check distance to the blade line segment
                        const dist = pointLineDist(e.x, e.y, startX, startY, tipX, tipY);

                        // Check if enemy is within the segment length (projection)
                        const dx = tipX - startX;
                        const dy = tipY - startY;
                        const lenSq = dx * dx + dy * dy;
                        const t = ((e.x - startX) * dx + (e.y - startY) * dy) / lenSq;

                        // t >= 0 && t <= 1 ensures hit is between start and end
                        if (t >= 0 && t <= 1 && dist < thickness + e.size) {
                            e.takeDamage(weaponData.attackPower * getDamageMultiplier());
                            createParticles(e.x, e.y, weaponData.color, 3);
                            const pushA = Math.atan2(e.y - player.y, e.x - player.x);
                            e.pushX += Math.cos(pushA) * 5;
                            e.pushY += Math.sin(pushA) * 5;
                            soundManager.playBlade();
                        }
                    });
                }
            }

            draw(weaponData) {
                const sx = player.x - camera.x;
                const sy = player.y - camera.y;
                const range = weaponData.range;

                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(this.angle);

                ctx.shadowBlur = 15; ctx.shadowColor = weaponData.color;
                ctx.fillStyle = weaponData.color;

                // Draw blade
                ctx.beginPath();
                ctx.moveTo(10, -5);
                ctx.lineTo(range, 0);
                ctx.lineTo(10, 5);
                ctx.lineTo(0, 0);
                ctx.fill();

                // Glow trail / Aura
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(10, -15);
                ctx.lineTo(range * 1.05, 0);
                ctx.lineTo(10, 15);
                ctx.fill();

                ctx.restore();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
        }

        class WhipHitbox {
            constructor(x, y, angle) {
                this.x = x; this.y = y; this.angle = angle;
                this.life = 10; this.maxLife = 10;
                this.range = weapons.whip.range * 1.5;
                this.width = Math.PI / 4;
            }
            update() {
                this.life--;
                if (this.life === 8) {
                    const dmg = weapons.whip.attackPower * getDamageMultiplier();
                    enemies.forEach(e => {
                        const dx = e.x - this.x;
                        const dy = e.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        const angleToEnemy = Math.atan2(dy, dx);

                        let angleDiff = angleToEnemy - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        if (dist < this.range && Math.abs(angleDiff) < this.width / 2) {
                            e.takeDamage(dmg);
                            const pushAngle = Math.atan2(dy, dx);
                            e.pushX += Math.cos(pushAngle) * 5;
                            e.pushY += Math.sin(pushAngle) * 5;
                        }
                    });
                }
            }
            draw() {
                const sx = this.x - camera.x;
                const sy = this.y - camera.y;
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(this.angle);

                ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#ff00ff';
                ctx.globalAlpha = this.life / 10;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(this.range / 2, -50 * (this.life % 2 == 0 ? 1 : -1), this.range, 0);
                ctx.stroke();

                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class ThunderStrike {
            constructor(x, y, targets) {
                this.segments = [{ x: x, y: y }, ...targets];
                this.life = 10;
            }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#ffff88'; ctx.lineWidth = 2; ctx.shadowBlur = 15; ctx.shadowColor = '#ffff88';
                ctx.globalAlpha = this.life / 10;
                ctx.beginPath();
                ctx.moveTo(this.segments[0].x - camera.x, this.segments[0].y - camera.y);
                for (let i = 1; i < this.segments.length; i++) {
                    ctx.lineTo(this.segments[i].x - camera.x, this.segments[i].y - camera.y);
                }
                ctx.stroke(); ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }

        class Landmine {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.life = weapons.mine.duration;
                this.triggerRadius = 40;
                this.blastRadius = weapons.mine.blastRadius || 120;
                this.active = false;
                this.armTimer = 30; // Delay before arming
            }
            update() {
                this.life--;
                if (this.armTimer > 0) this.armTimer--;
                else this.active = true;

                if (this.active) {
                    let target = null;
                    let minD = 150;
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minD) { minD = d; target = e; }
                    });

                    if (target) {
                        this.x += (target.x - this.x) * 0.05;
                        this.y += (target.y - this.y) * 0.05;
                    }

                    if (minD < this.triggerRadius) {
                        this.explode();
                    }
                }
            }
            explode() {
                this.life = 0;
                soundManager.playExplosion();
                createParticles(this.x, this.y, '#ffff00', 20);
                const dmg = weapons.mine.attackPower * getDamageMultiplier();
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < this.blastRadius) {
                        const damageMult = 1 - (dist / this.blastRadius) * 0.5;
                        e.takeDamage(dmg * damageMult);
                    }
                });
                bombs.push({ x: this.x, y: this.y, r: 0, maxR: this.blastRadius, alpha: 1, color: '#ffff00' });
            }
            draw() {
                const sx = this.x - camera.x;
                const sy = this.y - camera.y;
                ctx.fillStyle = this.active ? (Math.floor(frameCount / 10) % 2 === 0 ? '#ffff00' : '#ff0000') : '#333';
                ctx.beginPath(); ctx.arc(sx, sy, 6, 0, 6.28); ctx.fill();
                if (this.active) {
                    ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(sx, sy, 10 + Math.sin(frameCount * 0.2) * 2, 0, 6.28); ctx.stroke();
                }
            }
        }

        // --- Boss Base Class ---
        class BossBase {
            constructor(wave) {
                const angle = Math.random() * Math.PI * 2;
                this.x = player.x + Math.cos(angle) * 800;
                this.y = player.y + Math.sin(angle) * 800;
                this.x = clamp(this.x, 100, world.width - 100);
                this.y = clamp(this.y, 100, world.height - 100);

                this.hp = enemyBaseHp * 50 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 40;
                this.speed = 2.5;
                this.color = '#ff0000';
                this.marked = false;
                this.flash = 0;
                this.attackTimer = 0;
                this.isBoss = true;
                this.bossType = 'standard';
            }

            checkPlayerCollision(damage = 20) {
                if (Math.hypot(player.x - this.x, player.y - this.y) < player.size + this.size) {
                    takePlayerDamage(damage);
                }
            }

            drawBase(sx, sy) {
                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const rot = (frameCount * 0.05) + (i * Math.PI * 2 / 8);
                    const r = (i % 2 === 0) ? this.size : this.size * 0.7;
                    const px = sx + Math.cos(rot) * r;
                    const py = sy + Math.sin(rot) * r;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            drawHpBar(sx, sy) {
                const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = 'red'; ctx.fillRect(sx - 40, sy - 60, 80, 8);
                ctx.fillStyle = '#0f0'; ctx.fillRect(sx - 40, sy - 60, 80 * hpPercent, 8);
                ctx.strokeStyle = '#fff'; ctx.strokeRect(sx - 40, sy - 60, 80, 8);
                ctx.fillStyle = this.color; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                ctx.fillText(this.bossType.toUpperCase(), sx, sy - 65);
            }

            takeDamage(dmg) {
                this.hp -= dmg;
                totalDamageDealt += dmg;
                this.flash = 3;
                addFloatingText(this.x, this.y, Math.floor(dmg), '#fff');
                if (this.hp <= 0 && !this.marked) {
                    this.marked = true;
                    score += 1000;
                    for (let i = 0; i < 20; i++) {
                        gems.push({ x: this.x + (Math.random() - 0.5) * 100, y: this.y + (Math.random() - 0.5) * 100, val: 50, size: 8, marked: false });
                    }
                    player.hp = Math.min(player.maxHp, player.hp + 50);
                    addFloatingText(player.x, player.y, "+50 HP", "#00ff00");
                    createParticles(this.x, this.y, this.color, 50);
                    soundManager.playExplosion();
                    isBossActive = false;
                    soundManager.setBossMode(false);
                    const boxes = document.querySelectorAll('.stat-box');
                    boxes.forEach(b => b.classList.remove('boss-mode'));
                    updateUI();
                }
            }
        }

        class Boss extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'destroyer';
                this.color = '#ff0000';
            }

            update() {
                const a = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(a) * this.speed;
                this.y += Math.sin(a) * this.speed;
                if (this.flash > 0) this.flash--;
                this.checkPlayerCollision(20);

                this.attackTimer++;
                if (this.attackTimer > 100) {
                    this.attackTimer = 0;
                    for (let i = -2; i <= 2; i++) {
                        const targetX = player.x + Math.cos(a + i * 0.2) * 200;
                        const targetY = player.y + Math.sin(a + i * 0.2) * 200;
                        bossBullets.push(new Bullet(this.x, this.y, targetX, targetY, true));
                    }
                    soundManager.playShoot();
                }
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;
                this.drawBase(sx, sy);
                this.drawHpBar(sx, sy);
            }
        }

        class BossCharger extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'charger';
                this.color = '#ff6600';
                this.hp = enemyBaseHp * 50 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 50;
                this.speed = 1.5;
                this.chargeSpeed = 10;
                this.isCharging = false;
                this.chargeTimer = 0;
                this.chargeCooldown = 0;
                this.chargeTargetX = 0;
                this.chargeTargetY = 0;
                this.trail = [];
            }

            update() {
                if (this.flash > 0) this.flash--;

                if (this.isCharging) {
                    const a = Math.atan2(this.chargeTargetY - this.y, this.chargeTargetX - this.x);
                    this.x += Math.cos(a) * this.chargeSpeed;
                    this.y += Math.sin(a) * this.chargeSpeed;

                    if (frameCount % 2 === 0) {
                        this.trail.push({ x: this.x, y: this.y, life: 15 });
                    }

                    this.chargeTimer--;
                    if (this.chargeTimer <= 0) {
                        this.isCharging = false;
                        this.chargeCooldown = 180 + Math.floor(Math.random() * 180);
                        soundManager.playExplosion();
                        createParticles(this.x, this.y, this.color, 10);
                    }
                    this.checkPlayerCollision(35);
                } else {
                    const a = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(a) * this.speed;
                    this.y += Math.sin(a) * this.speed;
                    this.checkPlayerCollision(15);

                    this.chargeCooldown--;
                    if (this.chargeCooldown <= 0) {
                        this.isCharging = true;
                        this.chargeTimer = 60;
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        const dist = 1500;
                        this.chargeTargetX = this.x + Math.cos(angle) * dist;
                        this.chargeTargetY = this.y + Math.sin(angle) * dist;

                        soundManager.playBossSpawn();
                    }
                }

                this.trail.forEach(t => t.life--);
                this.trail = this.trail.filter(t => t.life > 0);
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;

                this.trail.forEach(t => {
                    ctx.globalAlpha = t.life / 15;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(t.x - camera.x, t.y - camera.y, this.size * 0.5, 0, 6.28);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                if (!this.isCharging && this.chargeCooldown < 30 && this.chargeCooldown > 0) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(player.x - camera.x, player.y - camera.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                const a = Math.atan2(player.y - this.y, player.x - this.x);
                ctx.beginPath();
                ctx.moveTo(sx + Math.cos(a) * this.size, sy + Math.sin(a) * this.size);
                ctx.lineTo(sx + Math.cos(a + 2.5) * this.size * 0.8, sy + Math.sin(a + 2.5) * this.size * 0.8);
                ctx.lineTo(sx + Math.cos(a - 2.5) * this.size * 0.8, sy + Math.sin(a - 2.5) * this.size * 0.8);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                this.drawHpBar(sx, sy);
            }
        }

        class BossSniper extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'sniper';
                this.color = '#00ff88';
                this.hp = enemyBaseHp * 28 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 35;
                this.speed = 1.8;
                this.preferredDistance = 250;
                this.laserChargeTime = 0;
                this.isChargingLaser = false;
                this.laserTargetX = 0;
                this.laserTargetY = 0;
            }

            update() {
                if (this.flash > 0) this.flash--;

                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                const a = Math.atan2(player.y - this.y, player.x - this.x);

                if (dist < this.preferredDistance - 50) {
                    this.x -= Math.cos(a) * this.speed;
                    this.y -= Math.sin(a) * this.speed;
                } else if (dist > this.preferredDistance + 50) {
                    this.x += Math.cos(a) * this.speed * 0.5;
                    this.y += Math.sin(a) * this.speed * 0.5;
                } else {
                    this.x += Math.cos(a + Math.PI / 2) * this.speed * 0.3 * Math.sin(frameCount * 0.05);
                    this.y += Math.sin(a + Math.PI / 2) * this.speed * 0.3 * Math.sin(frameCount * 0.05);
                }

                this.x = clamp(this.x, 50, world.width - 50);
                this.y = clamp(this.y, 50, world.height - 50);

                this.checkPlayerCollision(10);

                this.attackTimer++;
                if (!this.isChargingLaser && this.attackTimer > 100) {
                    this.isChargingLaser = true;
                    this.laserChargeTime = 60;
                    this.laserTargetX = player.x;
                    this.laserTargetY = player.y;
                }

                if (this.isChargingLaser) {
                    this.laserChargeTime--;
                    this.laserTargetX += (player.x - this.laserTargetX) * 0.02;
                    this.laserTargetY += (player.y - this.laserTargetY) * 0.02;

                    if (this.laserChargeTime <= 0) {
                        this.isChargingLaser = false;
                        this.attackTimer = 0;
                        soundManager.playThunder();

                        const laserAngle = Math.atan2(this.laserTargetY - this.y, this.laserTargetX - this.x);
                        const laserLength = 800;
                        const endX = this.x + Math.cos(laserAngle) * laserLength;
                        const endY = this.y + Math.sin(laserAngle) * laserLength;

                        if (pointLineDist(player.x, player.y, this.x, this.y, endX, endY) < player.size + 10) {
                            takePlayerDamage(25);
                        }

                        laserBeams.push({ x1: this.x, y1: this.y, x2: endX, y2: endY, life: 15, w: { range: laserLength } });
                    }
                }
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;

                if (this.isChargingLaser) {
                    ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + 0.7 * (1 - this.laserChargeTime / 60)})`;
                    ctx.lineWidth = 2 + (60 - this.laserChargeTime) * 0.2;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(this.laserTargetX - camera.x, this.laserTargetY - camera.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(sx, sy - this.size);
                ctx.lineTo(sx + this.size * 0.7, sy);
                ctx.lineTo(sx, sy + this.size);
                ctx.lineTo(sx - this.size * 0.7, sy);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(sx, sy, this.size + 10, 0, 6.28);
                ctx.stroke();

                this.drawHpBar(sx, sy);
            }
        }

        class BossTeleporter extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'phantom';
                this.color = '#aa00ff';
                this.hp = enemyBaseHp * 40 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 35;
                this.speed = 2.0;
                this.teleportCooldown = 0;
                this.isTeleporting = false;
                this.teleportPhase = 0;
                this.nextX = 0;
                this.nextY = 0;
                this.alpha = 1;
            }

            update() {
                if (this.flash > 0) this.flash--;

                if (this.isTeleporting) {
                    this.teleportPhase++;
                    if (this.teleportPhase < 15) {
                        this.alpha = 1 - this.teleportPhase / 15;
                    } else if (this.teleportPhase === 15) {
                        this.x = this.nextX;
                        this.y = this.nextY;
                        createParticles(this.x, this.y, this.color, 15);
                    } else if (this.teleportPhase < 30) {
                        this.alpha = (this.teleportPhase - 15) / 15;
                    } else {
                        this.isTeleporting = false;
                        this.teleportCooldown = 90;
                        this.alpha = 1;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            bossBullets.push(new Bullet(this.x, this.y, this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100, true));
                        }
                        soundManager.playShoot();
                    }
                } else {
                    const a = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(a) * this.speed;
                    this.y += Math.sin(a) * this.speed;

                    this.teleportCooldown--;
                    if (this.teleportCooldown <= 0) {
                        this.isTeleporting = true;
                        this.teleportPhase = 0;
                        const teleportType = Math.random();
                        let angle, dist;

                        if (teleportType < 0.5) {
                            angle = player.lastMoveAngle + (Math.random() - 0.5) * 0.5;
                            dist = 250 + Math.random() * 150;
                            this.nextX = player.x + Math.cos(angle) * dist;
                            this.nextY = player.y + Math.sin(angle) * dist;
                        } else if (teleportType < 0.7) {
                            angle = Math.atan2(player.y - this.y, player.x - this.x) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                            dist = 150 + Math.random() * 100;
                            this.nextX = player.x + Math.cos(angle) * dist;
                            this.nextY = player.y + Math.sin(angle) * dist;
                        } else if (teleportType < 0.85) {
                            angle = Math.atan2(player.y - this.y, player.x - this.x) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                            dist = 180 + Math.random() * 120;
                            this.nextX = this.x + Math.cos(angle) * dist;
                            this.nextY = this.y + Math.sin(angle) * dist;
                        } else {
                            const behindAngle = Math.atan2(this.y - player.y, this.x - player.x);
                            this.nextX = player.x + Math.cos(behindAngle) * 150;
                            this.nextY = player.y + Math.sin(behindAngle) * 150;
                        }

                        this.nextX = clamp(this.nextX, 50, world.width - 50);
                        this.nextY = clamp(this.nextY, 50, world.height - 50);
                        soundManager.playThunder();
                        createParticles(this.x, this.y, this.color, 15);
                    }

                    this.checkPlayerCollision(15);
                }
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;

                ctx.globalAlpha = this.alpha;

                if (this.isTeleporting && this.teleportPhase < 15) {
                    ctx.strokeStyle = this.color;
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.nextX - camera.x, this.nextY - camera.y, this.size, 0, 6.28);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + frameCount * 0.02;
                    const px = sx + Math.cos(angle) * this.size;
                    const py = sy + Math.sin(angle) * this.size;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.globalAlpha = 1;
                this.drawHpBar(sx, sy);
            }
        }

        class BossSummoner extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'summoner';
                this.color = '#ffaa00';
                this.hp = enemyBaseHp * 45 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 45;
                this.speed = 1.5;
                this.summonCooldown = 0;
                this.orbits = [];
                this.shieldActive = false;
            }

            update() {
                if (this.flash > 0) this.flash--;

                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                const a = Math.atan2(player.y - this.y, player.x - this.x);

                if (dist < 250) {
                    this.x -= Math.cos(a) * this.speed;
                    this.y -= Math.sin(a) * this.speed;
                } else if (dist > 400) {
                    this.x += Math.cos(a) * this.speed * 0.5;
                    this.y += Math.sin(a) * this.speed * 0.5;
                }

                this.x = clamp(this.x, 50, world.width - 50);
                this.y = clamp(this.y, 50, world.height - 50);

                this.checkPlayerCollision(15);

                this.summonCooldown--;
                if (this.summonCooldown <= 0) {
                    this.summonCooldown = 180;
                    const count = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < count; i++) {
                        const spawnAngle = (i / count) * Math.PI * 2;
                        const e = new Enemy();
                        e.x = this.x + Math.cos(spawnAngle) * 80;
                        e.y = this.y + Math.sin(spawnAngle) * 80;
                        e.hp = enemyBaseHp * 0.5;
                        e.maxHp = e.hp;
                        e.color = '#ffcc00';
                        enemies.push(e);
                        createParticles(e.x, e.y, '#ffaa00', 5);
                    }
                    soundManager.playLevelUp();
                }

                this.orbits = this.orbits.filter(o => o.life > 0);
                this.orbits.forEach((o, i) => {
                    o.angle += 0.05;
                    o.life--;
                });

                this.attackTimer++;
                if (this.attackTimer > 120) {
                    this.attackTimer = 0;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        bossBullets.push(new Bullet(this.x, this.y, this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100, true));
                    }
                    soundManager.playShoot();
                }
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;

                this.orbits.forEach((o, i) => {
                    const ox = sx + Math.cos(o.angle) * 60;
                    const oy = sy + Math.sin(o.angle) * 60;
                    ctx.globalAlpha = o.life / 60;
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(ox, oy, 8, 0, 6.28);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
                    const r = (i % 2 === 0) ? this.size : this.size * 0.6;
                    const px = sx + Math.cos(angle) * r;
                    const py = sy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                if (this.summonCooldown < 60) {
                    ctx.strokeStyle = `rgba(255, 170, 0, ${1 - this.summonCooldown / 60})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 80, 0, 6.28);
                    ctx.stroke();
                }

                this.drawHpBar(sx, sy);
            }
        }

        class BossTank extends BossBase {
            constructor(wave) {
                super(wave);
                this.bossType = 'juggernaut';
                this.color = '#888888';
                this.hp = enemyBaseHp * 80 * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;
                this.size = 55;
                this.speed = 1.0;
                this.armor = 0.5;

                this.slamCooldown = 0;
                this.isSlammingDown = false;
                this.slamPhase = 0;
                this.jumpHeight = 0;
                this.slamRadius = 250;

                this.beamCooldown = 100;
                this.isBeaming = false;
                this.beamTimer = 0;
                this.beamAngle = 0;
                this.beamDuration = 180;
                this.beamWarningTime = 60;
            }

            update() {
                if (this.flash > 0) this.flash--;

                if (this.isSlammingDown) {
                    this.slamPhase++;

                    // Phase 1: Jump Up (0-40)
                    if (this.slamPhase < 40) {
                        const t = this.slamPhase / 40;
                        this.jumpHeight = 150 * Math.sin(t * Math.PI / 2);
                    }
                    // Phase 2: Slam Down (40-50)
                    else if (this.slamPhase < 50) {
                        const t = (this.slamPhase - 40) / 10;
                        this.jumpHeight = 150 * (1 - t * t);
                    }
                    // Phase 3: Impact (50)
                    else if (this.slamPhase === 50) {
                        this.jumpHeight = 0;
                        const slamRadius = this.slamRadius;
                        if (Math.hypot(player.x - this.x, player.y - this.y) < slamRadius) {
                            takePlayerDamage(30);
                        }
                        soundManager.playExplosion();
                        createParticles(this.x, this.y, '#666', 40);
                    }

                    // Phase 4: Recovery (50-90)
                    if (this.slamPhase >= 90) {
                        this.isSlammingDown = false;
                        this.slamCooldown = 120;
                    }
                } else if (this.isBeaming) {
                    this.beamTimer++;
                    if (this.beamTimer < this.beamWarningTime) {
                        const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        let diff = targetAngle - this.beamAngle;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        this.beamAngle += diff * 0.05;
                    }
                    else if (this.beamTimer < this.beamWarningTime + this.beamDuration) {
                        const beamLength = 1000;
                        const bx = this.x + Math.cos(this.beamAngle) * beamLength;
                        const by = this.y + Math.sin(this.beamAngle) * beamLength;

                        if (pointLineDist(player.x, player.y, this.x, this.y, bx, by) < 40) {
                            if (player.contactDamageCooldown <= 0 && player.invincibleFrames <= 0) {
                                player.hp -= 2 * (1 - player.damageReduction);
                                player.contactDamageCooldown = 5;
                                addFloatingText(player.x, player.y, "-2", "#ff0000");
                                if (player.hp <= 0) gameState = "gameover";
                                updateUI();
                            }
                        }

                        if (frameCount % 4 === 0) createParticles(this.x + Math.cos(this.beamAngle) * 50, this.y + Math.sin(this.beamAngle) * 50, '#ff0000', 2);
                    }
                    else {
                        this.isBeaming = false;
                        this.beamCooldown = 300;
                    }
                } else {
                    const a = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(a) * this.speed;
                    this.y += Math.sin(a) * this.speed;

                    this.slamCooldown--;
                    if (this.slamCooldown <= 0 && Math.hypot(player.x - this.x, player.y - this.y) < this.slamRadius) {
                        this.isSlammingDown = true;
                        this.slamPhase = 0;
                        soundManager.playBossSpawn();
                    }

                    this.checkPlayerCollision(25);

                    this.beamCooldown--;
                    if (this.beamCooldown <= 0) {
                        this.isBeaming = true;
                        this.beamTimer = 0;
                        this.beamAngle = a;
                        soundManager.playThunder();
                    }
                }
            }

            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy)) return;

                // Draw Shadow/Impact Zone
                if (this.isSlammingDown) {
                    const progress = Math.min(1, this.slamPhase / 50);
                    const slamRadius = this.slamRadius;
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.1 + progress * 0.25})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, slamRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.4 + progress * 0.4})`;
                    ctx.lineWidth = 4 + progress * 2;
                    ctx.setLineDash([12, 10]);
                    ctx.beginPath();
                    ctx.arc(sx, sy, slamRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    if (this.slamPhase === 50) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath(); ctx.arc(sx, sy, slamRadius, 0, Math.PI * 2); ctx.fill();
                    }
                }

                if (this.isBeaming) {
                    const beamLength = 1000;
                    const ex = sx + Math.cos(this.beamAngle) * beamLength;
                    const ey = sy + Math.sin(this.beamAngle) * beamLength;

                    if (this.beamTimer < this.beamWarningTime) {
                        ctx.strokeStyle = `rgba(255, 0, 0, 0.5)`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([10, 10]);
                        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 40 + Math.sin(frameCount * 0.5) * 10;
                        ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000';
                        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 10;
                        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }

                const drawY = sy - this.jumpHeight;
                const shake = this.isSlammingDown && this.slamPhase >= 50 && this.slamPhase < 60 ? (Math.random() - 0.5) * 20 : 0;

                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.fillRect(sx - this.size + shake, drawY - this.size + shake, this.size * 2, this.size * 2);

                ctx.fillStyle = '#666';
                ctx.fillRect(sx - this.size * 0.7 + shake, drawY - this.size * 0.7 + shake, this.size * 1.4, this.size * 1.4);
                ctx.fillStyle = this.flash > 0 ? '#fff' : '#444';
                ctx.fillRect(sx - this.size * 0.4 + shake, drawY - this.size * 0.4 + shake, this.size * 0.8, this.size * 0.8);
                ctx.shadowBlur = 0;

                this.drawHpBar(sx, drawY);
                ctx.fillStyle = '#888'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                ctx.fillText(`ARMOR ${Math.floor(this.armor * 100)}%`, sx, drawY - 75);
            }
        }

        function createRandomBoss(wave) {
            const bossTypes = [Boss, BossCharger, BossSniper, BossTeleporter, BossSummoner, BossTank];
            const BossClass = bossTypes[Math.floor(Math.random() * bossTypes.length)];
            return new BossClass(wave);
        }

        class Enemy {
            constructor() {
                const edge = Math.floor(Math.random() * 4);
                const d = Math.max(canvas.width, canvas.height) / 2 + 50;
                let sx = player.x, sy = player.y;
                if (edge == 0) sy -= d; if (edge == 1) sx += d; if (edge == 2) sy += d; if (edge == 3) sx -= d;
                sx += (Math.random() - 0.5) * 500; sy += (Math.random() - 0.5) * 500;
                this.x = clamp(sx, 0, world.width);
                this.y = clamp(sy, 0, world.height);

                const wavePattern = wave % 6;
                const r = Math.random() * 100;
                let type = 'normal';

                if (wavePattern === 0) {
                    if (r > 90) type = 'runner'; else if (r > 70) type = 'tank';
                } else if (wavePattern === 1) {
                    if (r > 40) type = 'tank'; else if (r > 85) type = 'runner';
                } else if (wavePattern === 2) {
                    if (r > 30) type = 'runner'; else if (r > 80) type = 'tank';
                } else if (wavePattern === 3) {
                    if (r > 95) type = 'runner'; else if (r > 90) type = 'tank';
                } else if (wavePattern === 4) {
                    if (r > 65) type = 'runner'; else if (r > 35) type = 'tank';
                } else {
                    const types = ['normal', 'tank', 'runner'];
                    type = types[Math.floor(Math.random() * types.length)];
                }

                const t = enemyTypes[type];
                this.type = type;
                this.hp = enemyBaseHp * t.hpMul * (enemyGlobalHpMul || 1);
                this.maxHp = this.hp;

                let baseSpeed = 1.5 + Math.log(wave + 1) * 0.4;
                if (wave > 35) baseSpeed += (wave - 35) * 0.15;
                this.speed = baseSpeed * t.spdMul;
                this.color = t.color; this.size = 12;
                this.flash = 0; this.marked = false;
                this.pushX = 0; this.pushY = 0;
                this.isBoss = false;
            }
            update() {
                this.pushX *= 0.8; this.pushY *= 0.8;
                const a = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(a) * this.speed + this.pushX;
                this.y += Math.sin(a) * this.speed + this.pushY;
                if (this.flash > 0) this.flash--;

                if (Math.hypot(player.x - this.x, player.y - this.y) < player.size + this.size) {
                    takePlayerDamage(5);
                }
            }
            draw() {
                const sx = this.x - camera.x, sy = this.y - camera.y;
                if (isOffscreen(sx, sy, 50)) return;
                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                ctx.beginPath(); ctx.rect(sx - this.size, sy - this.size, this.size * 2, this.size * 2); ctx.fill();
                if (this.hp < this.maxHp) {
                    ctx.fillStyle = 'red'; ctx.fillRect(sx - 10, sy - 20, 20, 3);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(sx - 10, sy - 20, 20 * (this.hp / this.maxHp), 3);
                }
            }
            takeDamage(dmg) {
                this.hp -= dmg; totalDamageDealt += dmg; this.flash = 3;
                const a = Math.atan2(this.y - player.y, this.x - player.x);
                this.pushX = Math.cos(a) * 2; this.pushY = Math.sin(a) * 2;
                addFloatingText(this.x, this.y, Math.floor(dmg), '#fff');
                if (this.hp <= 0 && !this.marked) {
                    this.marked = true;
                    score += 10;
                    createParticles(this.x, this.y, this.color, 5);
                    gems.push({ x: this.x, y: this.y, val: 10 + wave * 2, size: 5, marked: false });
                    updateUI();
                }
            }
        }

        // --- Neon_Survivor.js ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const soundManager = new SoundManager();

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // UI
        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('overlay');
        const ui = document.getElementById('ui');
        const muteBtn = document.getElementById('muteBtn');
        const bossWarning = document.getElementById('bossWarning');
        const audioControls = document.getElementById('audioControls');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');

        const initialVolume = Math.round(soundManager.masterVolume * 100);
        volumeSlider.value = initialVolume;
        volumeValue.innerText = `${initialVolume}%`;

        startBtn.addEventListener('click', () => {
            soundManager.init();
            soundManager.startBGM();
            overlay.style.display = 'none';
            ui.style.display = 'flex';
            muteBtn.style.display = 'block';
            audioControls.style.display = 'block';
            gameState = "playing";
            resetGame();
            animate();
        });

        muteBtn.addEventListener('click', () => {
            const muted = soundManager.toggleMute();
            muteBtn.innerText = muted ? "ðŸ”‡ MUTED" : "ðŸ”Š MUTE";
        });

        volumeSlider.addEventListener('input', () => {
            const vol = volumeSlider.value / 100;
            soundManager.setVolume(vol);
            volumeValue.innerText = `${volumeSlider.value}%`;
        });

        let gameState = "start";
        let score = 0;
        let totalDamageDealt = 0;
        let wave = 1;
        let frameCount = 0;
        let timeSeconds = 0;
        let isBossActive = false;
        let enemyGlobalHpMul = 1;

        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === "gameover") {
                resetGame();
                gameState = "playing";
                soundManager.startBGM();
            }
            else if (gameState === "levelup") {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const boxWidth = 220, boxHeight = 280, gap = 20;
                const startX = (canvas.width - ((boxWidth * 3) + (gap * 2))) / 2;
                const startY = (canvas.height - boxHeight) / 2;

                for (let i = 0; i < upgradeOptions.length; i++) {
                    const x = startX + i * (boxWidth + gap);
                    if (clickX >= x && clickX <= x + boxWidth && clickY >= startY && clickY <= startY + boxHeight) {
                        upgradeOptions[i].apply();
                        soundManager.playLevelUp();
                        gameState = "playing";
                        break;
                    }
                }
            }
        });

        // --- Entities ---
        const player = {
            x: 0, y: 0, size: 16, speed: 4.0, color: '#00aaff',
            maxHp: 100, hp: 100,
            weapons: [], weaponCooldowns: {},
            exp: 0, level: 1, nextLevelExp: 100,
            invincibleFrames: 0, contactDamageCooldown: 0, magnetRadius: 100,
            expMult: 1,
            lastMoveAngle: 0,
            adrenaline: 0,
            vitalStrike: 0,
            damageReduction: 0 // Fortress Skill
        };

        const camera = { x: 0, y: 0 };
        const world = { width: 3000, height: 3000 };
        const isOffscreen = (sx, sy, margin = 100) => sx < -margin || sx > canvas.width + margin || sy < -margin || sy > canvas.height + margin;

        let enemies = [], bullets = [], particles = [], gems = [], weaponItems = [], upgradeOptions = [], floatingTexts = [];
        let laserBeams = [], bombs = [], thunders = [], whips = [], sanctuaryParticles = [], mines = [];
        let bossBullets = [];
        let rotatingBlades = [];

        let enemyBaseHp = 10;
        let spawnRate = 60;

        function resetGame() {
            weapons = JSON.parse(JSON.stringify(weaponsInitial));

            player.maxHp = 100;
            player.hp = 100;
            player.speed = 4.0;
            player.magnetRadius = 100;
            player.x = world.width / 2; player.y = world.height / 2;
            player.exp = 0; player.level = 1; player.nextLevelExp = 100;
            player.expMult = 1;
            player.adrenaline = 0;
            player.vitalStrike = 0;
            player.damageReduction = 0;
            enemyGlobalHpMul = 1;

            score = 0; wave = 1; frameCount = 0; timeSeconds = 0;
            totalDamageDealt = 0;
            enemyBaseHp = 10;
            enemies = []; bullets = []; particles = []; gems = []; weaponItems = []; floatingTexts = [];
            laserBeams = []; bombs = []; thunders = []; whips = []; sanctuaryParticles = []; mines = [];
            bossBullets = [];
            rotatingBlades = [];
            isBossActive = false;
            soundManager.setBossMode(false);
            soundManager.setSystemError(false);
            document.getElementById('systemError').style.display = 'none';
            soundManager.setWave(1);

            document.querySelectorAll('.stat-box').forEach(b => b.classList.remove('boss-mode'));

            const weaponKeys = Object.keys(weapons);
            const randomKey = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
            player.weapons = [randomKey];
            player.weaponCooldowns = {};
            player.weaponCooldowns[randomKey] = 0;

            updateUI();
        }

        function takePlayerDamage(rawDamage) {
            if (player.contactDamageCooldown > 0 || player.invincibleFrames > 0) return;

            // Fortress: Reduce damage
            const actualDamage = Math.max(1, rawDamage * (1 - player.damageReduction));

            player.hp -= actualDamage;
            player.contactDamageCooldown = 30;
            addFloatingText(player.x, player.y, `-${Math.floor(actualDamage)}`, "#ff0000");

            if (player.hp <= 0 && gameState !== "gameover") {
                gameState = "gameover";
                saveScore();
                soundManager.playGameOver();
            }
            updateUI();
        }

        function calcCooldownBoost() {
            if (player.adrenaline <= 0) return 1;
            const missingHpRatio = 1 - (player.hp / player.maxHp);
            return 1 + player.adrenaline * missingHpRatio * 0.3;
        }

        // Calculate Global Damage Multiplier
        function getDamageMultiplier() {
            let mult = 1.0;

            // Vital Strike: Bonus at high HP
            if (player.vitalStrike > 0) {
                const hpRatio = player.hp / player.maxHp;
                // Max +20% per level at 100% HP
                mult += (player.vitalStrike * 0.2 * hpRatio);
            }

            return mult;
        }

        function getWaveColor(alpha = 1.0) {
            const progress = Math.min(wave, 30) / 30;
            const r = Math.floor(0 + progress * 255);
            const g = Math.floor(170 + progress * 30);
            const b = Math.floor(255 - progress * 255);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        function spawnBoss() {
            if (isBossActive) return;
            isBossActive = true;
            soundManager.setBossMode(true);
            soundManager.playBossSpawn();
            enemies.push(createRandomBoss(wave));

            bossWarning.style.display = 'block';
            setTimeout(() => { bossWarning.style.display = 'none'; }, 3000);

            const boxes = document.querySelectorAll('.stat-box');
            boxes.forEach(b => b.classList.add('boss-mode'));
        }

        function updatePlayer() {
            if (player.contactDamageCooldown > 0) player.contactDamageCooldown--;
            const cooldownBoost = calcCooldownBoost();
            let dx = 0, dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy = -1; if (keys['s'] || keys['ArrowDown']) dy = 1;
            if (keys['a'] || keys['ArrowLeft']) dx = -1; if (keys['d'] || keys['ArrowRight']) dx = 1;
            if (dx || dy) {
                player.lastMoveAngle = Math.atan2(dy, dx);
                const l = Math.hypot(dx, dy);
                player.x += (dx / l) * player.speed; player.y += (dy / l) * player.speed;
            }
            player.x = clamp(player.x, 0, world.width);
            player.y = clamp(player.y, 0, world.height);
            camera.x += (player.x - canvas.width / 2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 0.1;

            // Handle Persistent Weapons (Photon Blade)
            if (player.weapons.includes('blade')) {
                const bladeCount = weapons.blade.count || 1;
                if (rotatingBlades.length < bladeCount) {
                    for (let i = rotatingBlades.length; i < bladeCount; i++) {
                        rotatingBlades.push(new RotatingBlade((i / bladeCount) * Math.PI * 2));
                    }
                }
                rotatingBlades.forEach(b => b.update(weapons.blade, cooldownBoost));
            }

            player.weapons.forEach(key => {
                if (player.weaponCooldowns[key] > 0) player.weaponCooldowns[key] -= cooldownBoost;
                else {
                    const w = weapons[key];
                    const effectiveFrames = w.cooldown / cooldownBoost;

                    if (key !== 'sanctuary' && key !== 'blade' && effectiveFrames < 9) {
                        soundManager.triggerOverheatSequence();
                    }

                    const playWeaponSound = (method) => {
                        method.call(soundManager);
                    };

                    const dmgMult = getDamageMultiplier();

                    if (key === 'gun') {
                        const target = findNearest(w.range);
                        if (target) {
                            bullets.push(new Bullet(player.x, player.y, target.x, target.y));
                            player.weaponCooldowns[key] = w.cooldown;
                            playWeaponSound(soundManager.playShoot);
                        }
                    }
                    else if (key === 'scatter') {
                        // Scatter Shot
                        const target = findNearest(w.range);
                        // Aim at target or forward
                        const aimAngle = target ? Math.atan2(target.y - player.y, target.x - player.x) : (player.lastMoveAngle || 0);

                        for (let i = 0; i < w.count; i++) {
                            const spread = (Math.random() - 0.5) * w.spread;
                            const fireAngle = aimAngle + spread;
                            const tx = player.x + Math.cos(fireAngle) * 100;
                            const ty = player.y + Math.sin(fireAngle) * 100;
                            // Pass w.range as maxDist
                            bullets.push(new Bullet(player.x, player.y, tx, ty, false, w.range));
                        }
                        player.weaponCooldowns[key] = w.cooldown;
                        playWeaponSound(soundManager.playShotgun);
                    }
                    else if (key === 'laser') {
                        const target = findNearest(w.range);
                        if (target) {
                            laserBeams.push({ x1: player.x, y1: player.y, x2: target.x, y2: target.y, life: 10, w: w });
                            player.weaponCooldowns[key] = w.cooldown;
                            playWeaponSound(soundManager.playRailgun);
                            const a = Math.atan2(target.y - player.y, target.x - player.x);
                            const lx = player.x + Math.cos(a) * w.range;
                            const ly = player.y + Math.sin(a) * w.range;
                            enemies.forEach(e => {
                                if (pointLineDist(e.x, e.y, player.x, player.y, lx, ly) < (e.isBoss ? e.size : e.size)) {
                                    e.takeDamage(w.attackPower * dmgMult);
                                }
                            });
                        }
                    }
                    else if (key === 'whip') {
                        whips.push(new WhipHitbox(player.x, player.y, player.lastMoveAngle));
                        whips.push(new WhipHitbox(player.x, player.y, player.lastMoveAngle + Math.PI));
                        player.weaponCooldowns[key] = w.cooldown;
                        playWeaponSound(soundManager.playWhip);
                    }
                    else if (key === 'bomb') { // Plasma Grenade
                        const target = findNearest(w.range);
                        if (target) {
                            bombs.push(new BombProjectile(player.x, player.y, target.x, target.y));
                            player.weaponCooldowns[key] = w.cooldown;
                        }
                    }
                    else if (key === 'thunder') {
                        const target = findNearest(w.range);
                        if (target) {
                            const chain = [target];
                            let curr = target;
                            const used = new Set([target]);
                            for (let i = 0; i < w.chainCount; i++) {
                                let next = null;
                                let minD = 200;
                                enemies.forEach(e => {
                                    if (!used.has(e)) {
                                        const d = Math.hypot(e.x - curr.x, e.y - curr.y);
                                        if (d < minD) { minD = d; next = e; }
                                    }
                                });
                                if (next) { chain.push(next); used.add(next); curr = next; }
                            }
                            thunders.push(new ThunderStrike(player.x, player.y, chain));
                            chain.forEach(e => e.takeDamage(w.attackPower * dmgMult));
                            player.weaponCooldowns[key] = w.cooldown;
                            playWeaponSound(soundManager.playThunder);
                        }
                    }
                    else if (key === 'sanctuary') {
                        enemies.forEach(e => {
                            if (Math.hypot(e.x - player.x, e.y - player.y) < w.range + e.size) {
                                e.takeDamage(w.attackPower * dmgMult);
                            }
                        });
                        player.weaponCooldowns[key] = w.cooldown;
                        if (frameCount % 5 === 0) sanctuaryParticles.push({ x: player.x + (Math.random() - 0.5) * w.range * 1.5, y: player.y + (Math.random() - 0.5) * w.range * 1.5, life: 20 });
                    }
                    else if (key === 'mine') {
                        mines.push(new Landmine(player.x, player.y));
                        player.weaponCooldowns[key] = w.cooldown;
                    }
                }
            });
        }

        function findNearest(range) {
            let t = null, md = range;
            enemies.forEach(e => {
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d < md) { md = d; t = e; }
            });
            return t;
        }

        function pointLineDist(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D, lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return Math.hypot(px - xx, py - yy);
        }

        function generateUpgradeOptions() {
            upgradeOptions = [];
            let pool = [...upgrades];

            pool = pool.filter(opt => {
                if (opt.id === 'adrenaline' && player.adrenaline >= 3) return false;
                if (opt.id === 'vital_strike' && player.vitalStrike >= 3) return false;
                return true;
            });

            const forceWeapon = (wave >= 1 && player.weapons.length === 1);

            const weaponChance = forceWeapon ? 1.0 : 0.6;

            if (player.weapons.length < 3) {
                if (Math.random() < weaponChance) {
                    const availWeapons = Object.keys(weapons).filter(k => !player.weapons.includes(k));
                    availWeapons.forEach(k => {
                        pool.push({
                            id: 'new_' + k, name: 'New: ' + weapons[k].name, description: weapons[k].description,
                            apply: () => { player.weapons.push(k); player.weaponCooldowns[k] = 0; }
                        });
                    });
                }
            }

            pool = pool.filter(opt => {
                const specials = ['adrenaline', 'curse', 'vital_strike', 'fortress'];
                if (specials.includes(opt.id) && Math.random() > 0.15) return false;
                return true;
            });

            const finalOptions = [];

            if (forceWeapon) {
                const weaponOptions = pool.filter(o => o.id.startsWith('new_'));
                if (weaponOptions.length > 0) {
                    const idx = Math.floor(Math.random() * weaponOptions.length);
                    finalOptions.push(weaponOptions[idx]);
                    const poolIdx = pool.indexOf(weaponOptions[idx]);
                    if (poolIdx > -1) pool.splice(poolIdx, 1);
                }
            }

            if (pool.length === 0) pool.push(upgrades[0]);

            while (finalOptions.length < 3) {
                if (pool.length === 0) break;
                const idx = Math.floor(Math.random() * pool.length);
                finalOptions.push(pool[idx]);
                pool.splice(idx, 1);
            }
            upgradeOptions = finalOptions;
        }
        function saveScore() {
            const result = {
                score: score,
                time: document.getElementById('timeDisplay').innerText,
                wave: wave,
                damage: Math.floor(totalDamageDealt),
                weapons: player.weapons.map(w => weapons[w].name),
                date: new Date().toLocaleString()
            };

            let highScores = getHighScores();
            highScores.push(result);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 5);

            localStorage.setItem('neonSurvivorScores', JSON.stringify(highScores));
        }

        function getHighScores() {
            const stored = localStorage.getItem('neonSurvivorScores');
            return stored ? JSON.parse(stored) : [];
        }

        function updateUI() {
            document.getElementById('scoreDisplay').innerText = score;
            document.getElementById('waveNum').innerText = wave;
            document.getElementById('hpText').innerText = Math.floor(player.hp) + "/" + player.maxHp;
            document.getElementById('hpBar').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + "%";
            document.getElementById('levelText').innerText = player.level;
            document.getElementById('expBar').style.width = (player.exp / player.nextLevelExp) * 100 + "%";
            document.getElementById('weaponDisplay').innerText = player.weapons.map(w => weapons[w].name).join(', ');
        }

        function drawGridLines(color) {
            const gridSize = 100;
            const offX = -camera.x % gridSize, offY = -camera.y % gridSize;
            ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.beginPath();
            for (let x = offX; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = offY; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();
        }

        function animate() {
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === "playing") {
                frameCount++;
                updatePlayer();

                const spawnInterval = Math.max(10, spawnRate - wave * 2);
                const bossSpawnModifier = isBossActive ? 1.43 : 1;
                if (frameCount % Math.floor(spawnInterval * bossSpawnModifier) === 0) enemies.push(new Enemy());

                if (frameCount % 60 === 0) {
                    timeSeconds++;

                    if (timeSeconds % 30 === 0) {
                        wave++;
                        if (wave <= 35) {
                            enemyBaseHp = 10 * Math.pow(wave, 0.9);
                        } else {
                            enemyBaseHp = (10 * Math.pow(35, 0.9)) + (wave - 35) * 50;
                        }
                        soundManager.setWave(wave);
                        if (wave % 5 === 0) {
                            spawnBoss();
                        }
                        updateUI();
                    }
                    const m = Math.floor(timeSeconds / 60).toString().padStart(2, '0');
                    const s = (timeSeconds % 60).toString().padStart(2, '0');
                    document.getElementById('timeDisplay').innerText = m + ":" + s;
                }

                // Grid and Background
                const waveIntensity = 1 + (Math.min(wave, 30) / 30) * 0.5;
                const baseBeat = (soundManager.current16thNote % 4 === 0) ? 0.2 : 0.05;
                const beat = baseBeat * waveIntensity;

                const gridColor = isBossActive ? `rgba(255,0,0,${beat + 0.2})` : getWaveColor(beat);

                // Boss Background Effect
                if (isBossActive) {
                    const pulse = 0.15 + Math.sin(frameCount * 0.1) * 0.05;
                    ctx.fillStyle = `rgba(50, 0, 0, ${pulse})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Add Vignette
                    const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.height / 3, canvas.width / 2, canvas.height / 2, canvas.height);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(1, 'rgba(100, 0, 0, 0.4)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                drawGridLines(gridColor);

                const boundaryColor = isBossActive ? 'rgba(255,0,0,0.6)' : 'rgba(0,170,255,0.5)';
                ctx.strokeStyle = boundaryColor;
                ctx.lineWidth = 4;
                ctx.setLineDash([20, 10]);
                ctx.strokeRect(-camera.x, -camera.y, world.width, world.height);
                ctx.setLineDash([]);

                const warningWidth = 50;
                ctx.fillStyle = isBossActive ? 'rgba(255,0,0,0.1)' : 'rgba(255,100,0,0.1)';
                ctx.fillRect(-camera.x, -camera.y, world.width, warningWidth);
                ctx.fillRect(-camera.x, world.height - camera.y - warningWidth, world.width, warningWidth);
                ctx.fillRect(-camera.x, -camera.y, warningWidth, world.height);
                ctx.fillRect(world.width - camera.x - warningWidth, -camera.y, warningWidth, world.height);

                gems.forEach((g, i) => {
                    const d = Math.hypot(g.x - player.x, g.y - player.y);
                    if (d < player.magnetRadius) {
                        g.x += (player.x - g.x) * 0.1; g.y += (player.y - g.y) * 0.1;
                        if (d < 20) {
                            player.exp += g.val * (player.expMult || 1);
                            soundManager.playGem(); g.marked = true;
                            if (player.exp >= player.nextLevelExp) {
                                player.level++; player.exp -= player.nextLevelExp; player.nextLevelExp = Math.floor(player.nextLevelExp * 1.15);
                                gameState = "levelup"; generateUpgradeOptions(); updateUI();
                            }
                            updateUI();
                        }
                    }
                    ctx.fillStyle = g.val > 20 ? '#ff00ff' : '#0f0';
                    ctx.beginPath(); ctx.arc(g.x - camera.x, g.y - camera.y, g.size || 4, 0, 6.28); ctx.fill();
                    if (g.marked) gems.splice(i, 1);
                });

                // Weapon Multiplier Logic for Bullets
                const dmgMult = getDamageMultiplier();

                bullets.forEach((b, i) => {
                    b.update(); b.draw();
                    if (!b.isEnemy) {
                        enemies.forEach(e => {
                            if (Math.hypot(e.x - b.x, e.y - b.y) < (e.isBoss ? e.size : e.size) + b.size) {
                                const baseDmg = (weapons.scatter && b.maxDist < 2000) ? weapons.scatter.attackPower : weapons.gun.attackPower;
                                e.takeDamage(baseDmg * dmgMult); b.marked = true;
                            }
                        });
                    } else {
                        if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.size) {
                            takePlayerDamage(10);
                            b.marked = true;
                        }
                    }
                    if (b.marked) bullets.splice(i, 1);
                });

                bossBullets.forEach((b, i) => {
                    b.update(); b.draw();
                    if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.size) {
                        takePlayerDamage(10);
                        b.marked = true;
                    }
                    if (b.marked) bossBullets.splice(i, 1);
                });

                bombs.forEach((b, i) => {
                    if (b instanceof BombProjectile) {
                        b.update(); b.draw();
                        if (b.marked) bombs.splice(i, 1);
                    } else {
                        b.r += 5; b.alpha -= 0.05;
                        ctx.fillStyle = `rgba(255, 100, 0, ${b.alpha})`;
                        ctx.beginPath(); ctx.arc(b.x - camera.x, b.y - camera.y, b.r, 0, 6.28); ctx.fill();
                        if (b.alpha <= 0) bombs.splice(i, 1);
                    }
                });

                laserBeams.forEach((l, i) => {
                    l.life--;
                    ctx.strokeStyle = '#0ff'; ctx.lineWidth = l.life / 2; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
                    ctx.beginPath();
                    const a = Math.atan2(l.y2 - l.y1, l.x2 - l.x1);
                    ctx.moveTo(l.x1 - camera.x, l.y1 - camera.y);
                    ctx.lineTo((l.x1 + Math.cos(a) * l.w.range) - camera.x, (l.y1 + Math.sin(a) * l.w.range) - camera.y);
                    ctx.stroke(); ctx.shadowBlur = 0;
                    if (l.life <= 0) laserBeams.splice(i, 1);
                });

                whips.forEach((w, i) => { w.update(); w.draw(); if (w.life <= 0) whips.splice(i, 1); });
                thunders.forEach((t, i) => { t.update(); t.draw(); if (t.life <= 0) thunders.splice(i, 1); });
                mines.forEach((m, i) => { m.update(); m.draw(); if (m.life <= 0) mines.splice(i, 1); });
                rotatingBlades.forEach(b => b.draw(weapons.blade));

                sanctuaryParticles.forEach((p, i) => {
                    p.life--;
                    ctx.fillStyle = `rgba(0, 255, 255, ${p.life / 20})`;
                    ctx.fillRect(p.x - camera.x, p.y - camera.y, 4, 4);
                    if (p.life <= 0) sanctuaryParticles.splice(i, 1);
                });
                if (player.weapons.includes('sanctuary')) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.beginPath(); ctx.arc(player.x - camera.x, player.y - camera.y, weapons.sanctuary.range, 0, 6.28); ctx.stroke();
                }

                enemies.forEach((e, i) => { e.update(); e.draw(); if (e.marked) enemies.splice(i, 1); });

                ctx.fillStyle = player.color; ctx.shadowBlur = 15; ctx.shadowColor = player.color;
                ctx.beginPath(); ctx.arc(player.x - camera.x, player.y - camera.y, player.size, 0, 6.28); ctx.fill(); ctx.shadowBlur = 0;

                floatingTexts.forEach((t, i) => { t.update(); t.draw(); if (t.life <= 0) floatingTexts.splice(i, 1); });
                particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });

            } else if (gameState === "levelup") {
                drawGridLines('#333');
                enemies.forEach(e => e.draw());
                rotatingBlades.forEach(b => b.draw(weapons.blade));
                ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(player.x - camera.x, player.y - camera.y, player.size, 0, 6.28); ctx.fill();

                ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#fff"; ctx.font = "bold 40px Arial"; ctx.textAlign = "center";
                ctx.fillText("LEVEL UP", canvas.width / 2, 100);

                const boxWidth = 220, boxHeight = 280, gap = 20;
                const startX = (canvas.width - ((boxWidth * 3) + (gap * 2))) / 2;
                const startY = (canvas.height - boxHeight) / 2;

                upgradeOptions.forEach((opt, i) => {
                    const x = startX + i * (boxWidth + gap);
                    const y = startY;
                    const grad = ctx.createLinearGradient(x, y, x, y + boxHeight);
                    grad.addColorStop(0, '#222'); grad.addColorStop(1, '#111');
                    ctx.fillStyle = grad; ctx.fillRect(x, y, boxWidth, boxHeight);
                    ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 2; ctx.strokeRect(x, y, boxWidth, boxHeight);

                    ctx.fillStyle = '#00aaff'; ctx.font = 'bold 18px Arial'; ctx.fillText(opt.name, x + boxWidth / 2, y + 40);
                    ctx.fillStyle = '#ccc'; ctx.font = '14px Arial';
                    wrapText(ctx, opt.description, x + boxWidth / 2, y + 100, boxWidth - 20, 20);
                });
            } else if (gameState === "gameover") {
                ctx.fillStyle = "rgba(10, 0, 0, 0.9)"; ctx.fillRect(0, 0, canvas.width, canvas.height);

                const cx = canvas.width / 2;
                const cy = canvas.height / 2;

                // Title
                ctx.fillStyle = "#ff0000";
                ctx.font = "900 60px 'Courier New'";
                ctx.textAlign = "center";
                ctx.shadowBlur = 20; ctx.shadowColor = "red";
                ctx.fillText("SYSTEM FAILURE", cx, cy - 250);
                ctx.shadowBlur = 0;

                // Current Run Stats
                ctx.fillStyle = "#fff"; ctx.textAlign = "left"; ctx.font = "bold 20px 'Segoe UI'";
                const statsX = cx - 300;
                const statsY = cy - 180;

                ctx.fillStyle = "#00aaff"; ctx.fillText("SESSION REPORT", statsX, statsY);
                ctx.fillStyle = "#fff"; ctx.font = "16px 'Courier New'";

                const timeStr = document.getElementById('timeDisplay').innerText;
                const lines = [
                    `SCORE:        ${score}`,
                    `SURVIVAL:     ${timeStr}`,
                    `WAVE REACHED: ${wave}`,
                    `TOTAL DAMAGE: ${Math.floor(totalDamageDealt)}`,
                    `WEAPONS:      ${player.weapons.length}`
                ];

                lines.forEach((line, i) => {
                    ctx.fillText(line, statsX, statsY + 30 + (i * 25));
                });

                ctx.font = "12px Arial"; ctx.fillStyle = "#aaa";
                wrapText(ctx, player.weapons.map(w => weapons[w].name).join(', '), statsX, statsY + 170, 250, 16);

                const boardX = cx + 50;
                const boardY = cy - 180;
                ctx.fillStyle = "#ffaa00"; ctx.font = "bold 20px 'Segoe UI'";
                ctx.fillText("HIGH SCORES", boardX, boardY);

                const highScores = getHighScores();
                ctx.font = "14px 'Courier New'";
                highScores.forEach((s, i) => {
                    const y = boardY + 30 + (i * 40);
                    ctx.fillStyle = i === 0 ? "#ffff00" : "#fff";
                    ctx.fillText(`${i + 1}. ${s.score} pts - Wave ${s.wave}`, boardX, y);
                    ctx.fillStyle = "#888";
                    ctx.fillText(`   ${s.date.split(' ')[0]}`, boardX, y + 15);
                });

                const btnY = cy + 200;
                if (frameCount % 60 < 30) {
                    ctx.fillStyle = "#00ff00";
                    ctx.font = "bold 24px 'Courier New'";
                    ctx.textAlign = "center";
                    ctx.fillText("> CLICK TO REBOOT SYSTEM <", cx, btnY);
                }
            }

            if (wave > 30) {
                const progress = Math.min(1, (wave - 30) / 10);

                if (progress > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'saturation';
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = progress;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }

                const noiseIntensity = progress * 0.3;
                if (noiseIntensity > 0) {
                    const noiseCount = Math.floor(progress * 100);
                    for (let i = 0; i < noiseCount; i++) {
                        ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)';
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const w = Math.random() * 50 + 1;
                        const h = Math.random() * 2 + 1;
                        ctx.fillRect(x, y, w, h);
                    }
                }

                if (Math.random() < 0.05 + progress * 0.2) {
                    const h = Math.random() * (50 + progress * 100) + 10;
                    const y = Math.random() * canvas.height;
                    if (Math.random() < progress) {
                        const v = Math.random() * 50 + 200;
                        ctx.fillStyle = `rgba(${v}, ${v}, ${v}, ${0.2 + progress * 0.3})`;
                    } else {
                        ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.2)`;
                    }
                    ctx.fillRect(0, y, canvas.width, h);
                }

                if (Math.random() < 0.02 + progress * 0.1) {
                    const shake = 5 + progress * 20;
                    camera.x += (Math.random() - 0.5) * shake;
                    camera.y += (Math.random() - 0.5) * shake;
                }

                if (Math.random() < 0.01 + progress * 0.05) {
                    soundManager.playGlitch();
                }
            }

            requestAnimationFrame(animate);
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color));
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    ctx.fillText(line, x, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, y);
        }

        function addFloatingText(x, y, text, color) {
            floatingTexts.push(new FloatingText(x, y, text, color));
        }

        resetGame();
    </script>
</body>

</html>
